export class Middleware {
    #before = [];
    #after = [];
    /**
     * Register the middleware with the Middleware object
     *
     * @param fn The middleware function
     * @param pos The position the middleware should be run relative the the route handler
     * @returns The position of the middleware in its respective queue
     */
    register(fn, pos) {
        if (pos == MiddlewarePosition.Before)
            return this.#before.push(fn);
        return this.#after.push(fn);
    }
    /**
     * Runs all the middleware to be run before the route handler
     *
     * @param ctx The Context supplied by the router
     * @returns The Content object just before it reaches the route handler
     */
    async before(ctx) {
        for (const middleware of this.#before) {
            if (!ctx.isLocked())
                ctx = await Promise.resolve(middleware(ctx));
        }
        return ctx;
    }
    /**
     * Runs all the middleware to be run after the route handler
     *
     * @param ctx The Context from the route handler
     * @returns The final Context object
     */
    async after(ctx) {
        for (const middleware of this.#after) {
            if (!ctx.isLocked())
                ctx = await Promise.resolve(middleware(ctx));
        }
        return ctx;
    }
}
export var MiddlewarePosition;
(function (MiddlewarePosition) {
    MiddlewarePosition[MiddlewarePosition["Before"] = 0] = "Before";
    MiddlewarePosition[MiddlewarePosition["After"] = 1] = "After";
})(MiddlewarePosition || (MiddlewarePosition = {}));
//# sourceMappingURL=middleware.js.map